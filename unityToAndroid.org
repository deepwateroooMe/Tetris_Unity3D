#+latex_class: cn-article
#+title: Unity Export 导出到Android Studio再打包大致过程
#+author: deepwaterooo 

* 安卓导.jar .aar进unity几个细巧点
** 项目的build.grale
   #+BEGIN_SRC groovy
plugins {
    id 'com.android.library' // <<<<<<<<<<<<<<<<<<<< 可以直接把app 改成早类库就可以了,不同再导一个
}
android {
    namespace 'com.deepwaterooo.dwsdk' // <<<<<<<<<<<<<<<<<<<< 这个需要
    compileSdk 32
    defaultConfig {
        minSdk 25
        targetSdk 32
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
dependencies {
    compileOnly files('libs\\classes.jar') // <<<<<<<<<<<<<<<<<<<< compileOnly Unity里的这些类是分Mono il2cpp的,要区分
    implementation 'androidx.appcompat:appcompat:1.5.1'
    implementation 'com.google.android.material:material:1.7.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.4'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.0'
}
   #+END_SRC
** 修改AndroidMainfest.xml
   #+begin_SRC xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          package="com.deepwaterooo.dwsdk">
          <!-- 上面的包裹名称 -->
  <uses-permission android:name="android.permission.READ_PRIVILEGED_PHONE_STATE" />
  <application>
    <!-- 这下面原本是application里的,都 不要了       -->
    <!-- android:allowBackup="true" -->
    <!-- android:dataExtractionRules="@xml/data_extraction_rules" -->
    <!-- android:fullBackupContent="@xml/backup_rules" -->
    <!-- android:icon="@mipmap/ic_launcher" -->
    <!-- android:label="@string/app_name" -->
    <!-- android:roundIcon="@mipmap/ic_launcher_round" -->
    <!-- android:supportsRtl="true" -->
    <!-- android:theme="@style/Theme.MyApplication" -->
    <!-- tools:targetApi="31"> -->

    <!-- 这个类的名字要写全,不写全有可能会出现找不到类 -->
    <activity
        android:name="com.deepwaterooo.dwsdk.MainActivity" 
        android:exported="true">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
      <!-- <meta-data -->
      <!--     android:name="android.app.lib_name" -->
      <!--     android:value="" /> -->
      <!-- 将上面缺省的,改成下面的, 这里的原理还没有弄懂,为什么一定要这么写 -->
      <meta-data
          android:name="unityplayer.UnityActivity"
          android:value="true" />
    </activity>
  </application>
</manifest>
   #+END_SRC
** 导文件(打.jar包给unity用)
- 最后–选择菜单栏 *Build -> Make Moudle* ’你的项目名’，build完成后会在项目中创建一个build文件夹，在 *build/intermediates/aar_main_jar/debug/* 选择 *classes.jar* 包，用解压软件打开，删除里面unity3d文件夹，避免在unity发布时重复。
- 然后重新打成是.jar包,导入unity中; 将 *AndroidMainfest.xml* 也导入unity。
- 如果导入的是 aar，有以下几点需要注意： *这个需要自己打一次测试一下*
  - 删除 unity_classes.jar 冲突文件，在 aar 的 lib 里
  - 删除包根目录下面的 Android 配置文件（先复制一份出来）
  - 删除 aar 跟目下的 classes.jar 里面的 BuildConfig.class 文件

* some commands use as reference for later debugging 
  #+BEGIN_SRC shell
jar cvf classes.jar -C classes/ .

jar cvf deepwaterooo_activity.jar -C classes/ .       

cp deepwaterooo_activity.jar /mnt/f/unityProjects/dwsdkTest/Assets/Plugins/Android 

zip -r dwsdk-debug.zip ./*

cp dwsdk-debug.aar /mnt/f/tetris3D/trunk/client/trunk/Assets/Plugins/Android/

cp deepwaterooo_activity.jar /mnt/f/tetris3D/trunk/client/trunk/Assets/Plugins/Android/

jar cvf com.android.support.support-compat-26.1.0.aar -C com.android.support.support-compat-26.1.0/ .

# gf 首先检查是否crash掉了 
grep -nE "FATAL EXCEPTION:" log1.log

# lst 抓取最后一个
tac log1.log | awk '!flag; /FATAL EXCEPTION: main/{flag = 1};' | tac > cur.log

# tl 抓取从某个时间点开始的
tac log1.log | awk '!flag; /:00/{flag = 1};' | tac > cur.log

grep -nE "com.unity3d.player|UnityPlayerActivity|GameApplication" cur.log > tmp.log

grep -nE "com.unity3d.player | UnityPlayerActivity" cur.log

grep -nE "com.defaultcompany.trunk | UnityPlayerActivity" cur.log
  #+END_SRC

* 导出的unity项目文件大致是这样的
- 大致过程记一下,用作参考,原理还没有吃透,细节又比较多,容易忘记.作个笔记记一下,给自己用作参考
   
[[./pic/unityToAndroid_20221123_222322.png]]
- 下面是2019年的版本可以打出两个文件夹,一个主工程,一个类库的导出包,2017年我用的版本打不出来,还需要想得再深一点多点儿,到可以按照这个笔记过程打包才行
- 原始自己参考的项目是用2017版本的,当时没有吃透这里面的构建关系,当时以为只能用2017的unity和2017的Visual Studio才能开发.现在知道2019的版本能够导出自己可以调试的Android Studio项目,而unity 2017版本的导出来自己还仍不知道该如何从Android Studio打包,那么就暂时先用2019的版本,先试图打出在安卓设备上可运行的包,才能move on.

* Android  启动运行 unity
** 在unity的AndroidMainfest.xml文件
- 把<intent-filter>-->删掉或者注释掉，留着的话，当我们把程序运行到手机或者模拟机上时会有两个图标。
- 其次是在<activity>里加入这行代码，实现多线程，避免在从unity返回Android时也将Android界面也结束了。
  #+begin_SRC xml
android:process=":raadidcard"
  #+END_SRC 

[[./pic/unityToAndroid_20221123_223227.png]]
** 在app的AndroidMainfest.xml文件里，在图中位置加入这两行代码：
   #+begin_SRC xml
xmlns:tools="http://schemas.android.com/tools"

tools:replace="android:icon,android:theme,android:allowBackup"
   #+END_SRC 
- 可以成片复制的代码如下:
  #+begin_SRC xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          xmlns:tools="http://schemas.android.com/tools"
          package="com.unity3d.player">

  <application
      android:allowBackup="true"
      android:dataExtractionRules="@xml/data_extraction_rules"
      android:fullBackupContent="@xml/backup_rules"
      android:icon="@mipmap/ic_launcher"
      android:label="@string/app_name"
      android:roundIcon="@mipmap/ic_launcher_round"
      android:supportsRtl="true"
      tools:replace="android:icon,android:theme,android:allowBackup"
      android:theme="@style/Theme.Test"
      tools:targetApi="31">

    <activity
        android:name=".MainActivity"
        android:exported="true">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
      <meta-data
          android:name="android.app.lib_name"
          android:value="" />
    </activity>

  </application>
</manifest>
  #+END_SRC 

[[./pic/unityToAndroid_20221123_223757.png]]

** 在app的build.gradle里加入这行代码。
   #+begin_SRC xml
ndk {
    abiFilters 'armeabi-v7a'
}
   #+END_SRC 
   
[[./pic/unityToAndroid_20221123_223842.png]]
** 在app的main->res->values->strings.xml里加入这行代码
- 都还没有去想,这句话能起到什么作用,应该是关系不大,或是可以跳过绕过的小细节
   #+begin_SRC xml
<string name="game_view_content_description">Game view</string>
   #+END_SRC 
- 进行这两步操作的原因是，我在运行到手机时，他显示硬件不支持或者闪退。加入上面两个代码后就可以正常启动unity。
- 我个人认为真正起作用的是上上一步关于手机架构的设置的ndk那三行,与上面字符串无关,应该是无关的
  
[[./pic/unityToAndroid_20221123_225409.png]]

** 点击按钮启动unity(画蛇添足)
- 感觉这个连接过程对于自己的项目就是画蛇添足.可是如何既能避开这一步,又能两者很好的平滑交互呢? 对于现在的自己,是个问题和挑战
- 在主工程的activity_main.xml 文件里添加一个按钮。MainActivity.java 里加入启动事件，如果在这里layout标红的话，就把鼠标移到layout下面，建立一个layout就行，我分析是主工程的问题，这个影响不大
#+begin_SRC xml
<Button
    android:id="@+id/showUnityBtn"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Show Unity"/>
#+END_SRC 

[[./pic/unityToAndroid_20221123_223751.png]]
- MainActivity.cs 里的回调设置 
#+BEGIN_SRC java
Button btn = (Button)findViewById(R.id.showUnityBtn);
btn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {

// <<<<<<<<<<<<<<<<<<<< UnityPlayerActivity <= com.unity3d.player 这里就是刚刚那个包名奇怪的地方,要不然 找不到 下面的 UnityPlayerActivity 类
            Intent intent = new Intent(MainActivity.this, UnityPlayerActivity.class); // <<<<<<<<<<<<<<<<<<<< UnityPlayerActivity

            startActivity(intent);
        }
    });
#+END_SRC

[[./pic/unityToAndroid_20221123_223852.png]]
** 在build.gradle中申明包裹类名称
- 说是现在在AndroidManifest.xml里申明包裹名称已经过时了,要在配置文件里申明,于是我在这里申明的:
#+BEGIN_SRC groovy
android {
    namespace 'com.unity3d.player'
}
#+END_SRC

[[./pic/unityToAndroid_20221124_090438.png]]

* 启动运行
  
[[./pic/unityToAndroid_20221123_225517.png]]

* Android Studio 类库中重复类的修复
  
[[./pic/unityToAndroid_20221124_221720.png]]
- 如果新导入的依赖库发生了 Duplicate class android.xx.xx 这种类型的报错可能就是两个库导入了重复的类，这时候只需要把build.gradle中新导入的依赖做如下处理
  #+begin_SRC xml
implementation ('com.xxx.xxx.xx:xx:1.0.0'){
    exclude group: "com.xxxx.xxxx"
}
  #+END_SRC 
- 上面这个方法我还没有试.下面的试过了可行
- 对，就是把新导入的依赖库的后面加上大括号并把重复导入包名填入相应的位置就可以解决了，有时候可能会好几个依赖库都重复了，这就比较难判断了
- 1.把MiyataOpenUISdk-1.0.2.aar改后缀成zip，得到解压后的MiyataOpenUISdk-1.0.2文件夹，里面包含classes.jar和res等。
  
[[./pic/unityToAndroid_20221124_221954.png]]
- 2.同理把classes.jar改后缀成zip，解压后得到classes文件夹，找到冲突的包，直接删除整个文件夹，如图
- 3.使用jar命令重新对classes文件夹打包成jar ,并替换掉之前的classes.jar。
#+begin_SRC shell
jar cvf classes.jar -C classes/ .
#+END_SRC 
- 4.同理，使用jar命令重新对MiyataOpenUISdk-1.0.2文件夹打包成aar ,得到的newMiyataOpenUISdk.aar即可使用。
#+begin_SRC shell
 jar cvf com.android.support.support-compat-26.1.0.aar -C com.android.support.support-compat-26.1.0/ .
#+END_SRC 

* 安卓Android Studio库包中有依赖的库包的解决方案 7.2.2
   #+BEGIN_SRC tex
Direct local .aar file dependencies are not supported when building an AAR.
   #+END_SRC 
- 在高版本的AndroidStudio并且使用了版本的gradle出现了上述问题可以按着如下引用
** 比较好一点的,是如下:在项目的根目录的build.gradle里申明类库unityLibrary的依赖的文件路径就可找到
#+begin_SRC xml
allprojects {
  buildscript {
      repositories {
          google()
          jcenter()
      }

      dependencies {
          classpath 'com.android.tools.build:gradle:7.2.2'
      }
  }

  repositories {
      google()
      jcenter()
     flatDir {
         dirs "${project(':unityLibrary').projectDir}/libs"
     }
  }
}

task clean(type: Delete) {
  delete rootProject.buildDir
}
#+END_SRC

[[./pic/unityToAndroid_20221125_144439.png]]

** 下面的只是一种解决方案,可能还不是很好
** 在你工程根目录下新建一个文件夹 *unitylibs* ，将你的aar文件放入，然后在该目录下新建一个build.gradle文件
    
[[./pic/unityToAndroid_20221124_161335.png]]
** 在settings.gradle 导入该工程
    #+begin_SRC xml
include ':unitylibs
    #+END_SRC 
    
[[./pic/unityToAndroid_20221124_161424.png]]
** 在你需要依赖的工程里面的build.gradle中增加依赖
- // 这里需要注意的是，unitylibs是你aar库所在文件夹
    #+begin_SRC xml
implementation project(path: ':unitylibs') 
    #+END_SRC 

[[./pic/unityToAndroid_20221124_162337.png]]
- 当然如果你有很多aar库，那么你需要在根目录创建一个LocalRepo目录，然后将你不同的aar库放在不同文件夹下。在setting.gradle分别导入
- 下面它是这么说的,可是我都把它们放在同一个类库里,看不行的话再移.为什么每个包都需要一个单独的类库呢?解偶多个不同包之间的依赖性?加载时的内存性能影响等?

* 那么现在就是说:安卓SDK与unity的交互与打包基本没有问题了
- This PC\HEYAN's S10+\Internal storage\Android\data\com.defaultcompany.trunk\files
  
[[./pic/unityToAndroid_20221125_171932.png]]

- 但对自己更大的挑战是:为什么unity里一个空物件挂载到热更新的过程,我打包之后在安卓手机上运行不出来,仍需要时间debug这个过程(呵呵,前面昨天还是前天已经想到问题的原因,不到因为探讨其它的想法,直到今天傍晚刚才整个过程才理通.不过目前仍是用unity直接到包,还有许多其它的细节小问题需要解决)
- 过程中遇到过,还会遇到很多不懂的问题,比如同样的某些android studio里加android:exported="true"各种标签等,如果只用unity打包,该如何实现呢?两套不同的打包机制都得弄明白.但都是这么一个学习的过程,不会被轻易挫败.
- 相比之下,安卓SDK的实现极其简单,可以放在后面
** FATAL EXCEPTION: main
   
[[./pic/unityToAndroid_20221124_101807.png]]
- 这个没有再出现了,根据这里改的:https://forum.unity.com/threads/android-crashes-after-update-project-to-unity-2020-3-9f.1126979/
- 但是游戏的界面仍然是渲染不出来,还在找原因 
#+BEGIN_SRC java
@Override protected void onDestroy () {
    Log.d(TAG, "onDestroy() ");
    // mUnityPlayer.destroy();
    mUnityPlayer.removeAllViews();
    mUnityPlayer.quit();
    super.onDestroy();
}
#+END_SRC 
** 类库包里的错误的修复问题
- 现在还不是很懂,或是还没有经历狠好地锻炼怎么改类库包里的错误,晚点儿再理会这些
  
[[./pic/unityToAndroid_20221124_163004.png]]
- 先只把这些有错误的类库包不连上

* 安卓设备上资源包的存放位置,以及是否本地存放有需要的资源包
  #+BEGIN_SRC text
This PC\HEYAN's S10+\Internal storage\Android\data\com.defaultcompany.trunk\files
  #+END_SRC

[[./pic/unityToAndroid_20221124_135846.png]]

  #+BEGIN_SRC tex
Application.dataPath             /data/app/package name-1/base.apk
Application.streamingAssetsPath jar:file:///data/app/package name-1/base.apk!/assets
Application.temporaryCachePath  /storage/emulated/0/Android/data/package name/cache
Application.persistentDataPath  /storage/emulated/0/Android/data/package name/files
  #+END_SRC 
- 看Android上的路径，跟iOS有点类似，简单说一下。Android的几个目录是apk程序包、内存存储(InternalStorage)和外部存储(ExternalStorage)目录。
- *apk程序包目录*: apk的安装路径，/data/app/package name-n/base.apk，dataPath就是返回此目录。
- *内部存储目录*: /data/data/package name-n/，用户自己或其它app都不能访问该目录。打开会发现里面有4个目录（需要root）
-     cache 缓存目录，类似于iOS的Cache目录
-     databases 数据库文件目录
-     files 类似于iOS的Documents目录
-     shared_prefs 类似于iOS的Preferences目录，用于存放常用设置，比如Unity3D的PlayerPrefs就存放于此
- 外部存储目录: 在内置或外插的sd上，用户或其它app都可以访问，外部存储目录又分私有和公有目录。
-     公有目录是像DCIM、Music、Movies、Download这样系统创建的公共目录，当然你也可以像微信那样直接在sd卡根目录创建一个文件夹。好处嘛，就是卸载app数据依旧存在。
-     私有目录在/storage/emulated/n/Android/data/package name/，打开可以看到里面有两个文件夹cache和files。为什么跟内部存储目录重复了？这是为了更大的存储空间，以防内存存储空间较小。推荐把不需要隐私的、较大的数据存在这里，而需要隐私的或较小的数据存在内部存储空间。
- 下面是各路径对应的Java访问方法：
  - apk包内: AssetManager.open(String filename)
  - 内部存储: context.getFilesDir().getPath() or context.getCacheDir().getPath()
  - 外部存储: context.getExternalFilesDir(null).getPath() or context.getExternalCacheDir().getPath()
理解了Android存储的原理，最后来说说开头提到的bug，Application.temporaryCachePath/persistentDataPath返回空字符串。这其实因为权限的原因，app没有声明访问外部存储空间的权限，但是Application.temporaryCachePath/ ApplicationpersistentDataPath却想返回外部存储的路径。这是Unity3D的bug，没有权限本应该抛出一个异常或者错误，让开发者知道原因。
- 经反复测试发现，有【外置SD卡】的设备上，如果声明读/写外部存储设备的权限，会返回外部存储路径，不声明则会返回内部存储路径，这样不会有问题。而在【无外置SD卡】的设备上，不管是否声明读/写外部存储设备的权限，Application.temporaryCachePath/persistentDataPath都返回外部存储路径，但是又没有权限，就可能会导致返回null了，之所以说可能是因为这个bug不是必现，如果出现了设备重启之后就好了，怀疑是linux设备mount问题。但是出了问题，我们不能跟用户说你重启一下手机就好了。
#+begin_SRC xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
#+END_SRC 

