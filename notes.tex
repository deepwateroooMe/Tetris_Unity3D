% Created 2022-12-26 Mon 20:36
\documentclass[9pt, b5paper]{article}
\usepackage{xeCJK}
\usepackage{minted}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beraserif}
\usepackage[scaled]{berasans}
\usepackage[scaled]{beramono}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{float}
\usepackage{textcomp}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{latexsym}
\usepackage{natbib}
\usepackage{geometry}
\geometry{left=1.2cm,right=1.2cm,top=1.5cm,bottom=1.2cm}
\newminted{common-lisp}{fontsize=\footnotesize} 
\usepackage[xetex,colorlinks=true,CJKbookmarks=true,linkcolor=blue,urlcolor=blue,menucolor=blue]{hyperref}
\author{deepwaterooo}
\date{\today}
\title{Unity Export 导出到Android Studio再打包大致过程原理}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 27.2 (Org mode 8.2.7c)}}
\begin{document}

\maketitle
\tableofcontents


\section{安卓SDK unity交互原理简单案例表述}
\label{sec-1}
\subsection{unity调用csharp, 普通方法(不带参数)}
\label{sec-1-1}
\begin{itemize}
\item 安卓SDK端定义一个类,unity C\#端通过固定的模式调用这个类,就可以了
\item java
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
public class AdPlatformSDK {
    public static AdPlatformSDK sInstance;

    public static AdPlatformSDK getInstance(Context context) {
        if (sInstance == null) {
            synchronized (AdPlatformSDK.class) {
                if (sInstance == null) 
                    sInstance = new AdPlatformSDK(context);
            }
        }
        return sInstance;
    }

    private AdPlatformSDK(Context context) {
        MMKV.initialize(context); 
    }
}
\end{minted}
\begin{itemize}
\item c\#端的代码
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
public class SDKMgr {
    private AndroidJavaObject _mAdplatormSDK;
    private AndroidJavaObject _unityPlayer;

    public void Init() {
        var unityPlayer = new AndroidJavaClass("com.unity3d.player.UnityPlayer");
        _unityPlayer = unityPlayer.GetStatic<AndroidJavaObject>("currentActivity");
        var jc = new AndroidJavaClass("com.yc.adplatform.AdPlatformSDK");
        _mAdplatormSDK = jc.CallStatic<AndroidJavaObject>("getInstance", _unityPlayer);
        // 这里的getInstance代表上面java代码中public static AdPlatformSDK getInstance(Context context)中的方法名字_unityPlayer 这个代表是参数Context 
    }
}
\end{minted}
\subsection{如何传递接口参数:}
\label{sec-1-2}
\begin{itemize}
\item 两端都分别定义完全相同的接口类(这个接口类中所申明的APIs都将成为两端互相调用的公用方法,作为桥梁沟通),两端都会有各自的实现
\item java
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
package com.yc.adplatform.ad.core;

public interface InitCallback {

    void onSuccess();  
    void onFailure();
    void onAdInitSuccess(); 
    void onAdInitFailure(); 
}
\end{minted}
\begin{itemize}
\item C\#接口
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
// 和上面的java对应 也就是重写
public interface IUnityInitCallback {

    void onSuccess(); 
    void onFailure();
    void onAdInitSuccess(); 
    void onAdInitFailure(); 
}
\end{minted}
\begin{itemize}
\item Unity端的接口类
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UnityInitCallback : AndroidJavaProxy {

    private readonly IUnityInitCallback listener;

// 这里最底层,一定是继承自安卓SDK端的接口,从而实现 安卓SDK端相关事件的向unity传递的注册监听与回调
    public UnityInitCallback(IUnityInitCallback listener)
        : base("com.bytedance.sdk.openadsdk.AdPlatformSDK$InitCallback") { // <<<<<<<<<<<<<<<<<<<< 
        this.listener = listener;
    }
    
    public void onSuccess() { // PostTask: 自定义的静态方法,多线程环境下,将待执行任务发布到任务链表
        InterfaceMgr.PostTask(() =>  this.listener.onSuccess());
    }
    public void onFailure() {
        InterfaceMgr.PostTask(() => this.listener.onFailure());
    }
    public void onAdInitSuccess() { // 广告初始化成功 
        InterfaceMgr.PostTask(() => this.listener.onAdInitSuccess());
    }
    public void onAdInitFailure() { // 广告初始化失嵊
        InterfaceMgr.PostTask(() => this.listener.onAdInitFailure());
    }
}
\end{minted}
\begin{itemize}
\item 接口管理器
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
public class InterfaceMgr: MonoBehaviour {

    private static InterfaceMgrinstance;

    // The thread safe task queue: 数据结构本身并不是多线程安全的,说它安全是因为在访问的时候上锁了
    private static List<Action> postTasks = new List<Action>(); // <<<<<<<<<<<<<<<<<<<< 
    private static List<Action> executing = new List<Action>(); // The executing buffer.

    private static InterfaceMgrInstance {
        get {
            CheckInstance();
            return instance;
        }
    }
// 用这个链表,可能就是为了上面提供给其它类一个公用调用方法
    public static void PostTask(Action task) { // Work thread post a task to the main thread.
        lock (postTasks) { // <<<<<<<<<<<<<<<<<<<< 
            postTasks.Add(task);
        }
    }
    
    [RuntimeInitializeOnLoadMethod]
    private static void CheckInstance() { // Start to run this InterfaceMgr.
        if (instance == null && Application.isPlaying) {
            var go = new GameObject("InterfaceMgr", typeof(InterfaceMgr));
            GameObject.DontDestroyOnLoad(go);
            instance = go.GetComponent<InterfaceMgr>();
        }
    }
    private void Awake() {
        GameObject.DontDestroyOnLoad(this);
    }
    private void OnDestroy() {
        postTasks.Clear(); // 这里是防,资源泄露
        executing.Clear();
        instance = null;
    }
    private void Update() { // 感觉这里用个链表postTasks好浪费
        lock (postTasks) { // 锁
            if (postTasks.Count > 0) {
                for (int i = 0; i < postTasks.Count; ++i) 
                    executing.Add(postTasks[i]);
                postTasks.Clear();
            }
        }
        for (int i = 0; i < executing.Count; ++i) {
            var task = executing[i];
            try {
                task();
            } catch (Exception e) {
                Debug.LogError(e.Message, this);
            }
        }
        executing.Clear();
    }
}
\end{minted}
\begin{itemize}
\item 接口的具体实现转为对象 看代码使其可以使用new
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

// 要把这里想明白:是unity C#的类,但它的作用功能是想要回调给安卓SDK,调用通知它[(为它注册设制几类不同事件的回调监听)]相关的监听
public class InitCallbackListener : IUnityInitCallback {

    private Action _InitFailurCall;
    private Action _InitSuccesscall;
    private Action _FailureCall;
    private Action _SuccessCall;

    public InitCallbackListener (Action InitFailurCall=null, Action InitSuccesscall=null, Action FailureCall =null, Action SuccessCall=null) {
        _InitFailurCall = InitFailurCall;
        _InitSuccesscall = InitSuccesscall;
        _FailureCall = FailureCall;
        _SuccessCall = SuccessCall;
    }

    public void onAdInitFailure() {
        _InitFailurCall?.Invoke();
        Debug.LogError("SDK初始化失败");
    }
    public void onAdInitSuccess() {
        _InitSuccesscall?.Invoke();
        Debug.LogError("SDK初始化成功");
    }
    public void onFailure() {
        _FailureCall?.Invoke();
        Debug.LogError("初始化失败");
    }
    public void onSuccess() {
        _SuccessCall?.Invoke();
        Debug.LogError("初始化成功");
    }
}
\end{minted}
\begin{itemize}
\item 那么我们调用下面这个java也就是安卓代码
\item java代码
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
  public void init(final Context context, String appId, final InitCallback initCallback) {}
\end{minted}
\begin{itemize}
\item C\#
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
InitCallbackListener initCallbackListener = new InitCallbackListener();
_mAdplatormSDK.Call("init", _unityPlayer, _appId, initCallbackListener);
// 参数可以自己设置
\end{minted}
\begin{itemize}
\item 其他的参数传递就比较简单了
\end{itemize}

\textasciitilde{}* 以前工作中的一个SDK与unity游戏交互的主要逻辑梳理
\begin{itemize}
\item 不同于网络上绝大多数的安卓SDK与游戏的交互,以前公司里是做了一个中介SDK,负责将公司封装的公司个性化安卓SDK与unity游戏端进行交互
\item 下面前两个文件是安卓SDK端的定义,中介SDK,公司原始SDK比较简单,可以后看.之后的文件是游戏端对中介SDK提供接口的对接衔接,把这些弄懂
\end{itemize}
\subsection{SquarePandaSDK.java: 这是个静态成员和静态方法类}
\label{sec-1-3}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
// 这个类是提供的公用方法,可以供unity游戏端调用SDK中的实现
public class SquarePandaSDK {
    public static final String TAG = "SquarePandaSDK"; 
    public static final String UnityGameobjectName = "SquarePanda"; // <<<<<<<<<< 要这个是作什么用的呢?

    public SquarePandaSDK() {}

// 定义了这个静态方法,在本类中也被多次用到,用于调用 unity,实现了SDK 对游戏端的调用或说事件通知
    public static void SendUnityMessage(String methodName, String parameter) {
        UnityPlayer.UnitySendMessage("SquarePanda", methodName, parameter != null ? parameter : "");
    }
    public static void GetBatteryStatus() {
        BluetoothUtil.getBatteryStatus(0L);
    }
    public static void KeepAppAlive() {
        Util.keepAppAlive();
    }
    public static boolean IsInternetConnected() {
        return NetworkUtil.checkInternetConnection(SquarePandaUnityActivity.mUnityPlayer.getContext());
    }
    public static void UploadFileWithName(String data, String name) {
        PlayerDO player = PlayerUtil.getSelectedPlayer(SquarePandaUnityActivity.instance);
        if(player == null) {
            return;
        } else {
            String n = (new StringBuilder()).append(player.getId()).append("_").append(name).append(".json").toString();
            byte d[] = data.getBytes();
            NetworkUtil.uploadFile(SquarePandaUnityActivity.instance, new ApiCallListener() {
                    public void onResponse(Object o) {
                    }
                    public void onFailure(Object o) {
                    }
                }
                , d, n);
            return;
        }
    }
    public static void DownloadFileWithName(String name) {
        PlayerDO player = PlayerUtil.getSelectedPlayer(SquarePandaUnityActivity.instance);
        if(player == null) {
            return;
        } else {
            String n = (new StringBuilder()).append(player.getId()).append("_").append(name).append(".json").toString();
            NetworkUtil.downloadFile(SquarePandaUnityActivity.instance, new ApiCallListener() {
                    public void onResponse(Object o) {
                        ResponseBody r = (ResponseBody)o;
                        try
                        {
                            byte b[] = r.bytes();
                            String retrieved = new String(b);
                            SquarePandaSDK.SendUnityMessage("_onLoadFileSuccess", retrieved);
                        }
                        catch(IOException e)
                        {
                            e.printStackTrace();
                            SquarePandaSDK.SendUnityMessage("_onLoadFileFail", "");
                        }
                    }
                    public void onFailure(Object o) {
                        SquarePandaSDK.SendUnityMessage("_onLoadFileFail", "");
                    }
                }
                , n);
            return;
        }
    }
    public static void Init() {
        PlayerUtil.startSplashScreenActivity(SquarePandaUnityActivity.instance);
    }
    public static void StartSplashScreenActivity() {
        PlayerUtil.startSplashScreenActivity(SquarePandaUnityActivity.instance);
    }
    public static void StartGameActivity() {}
    public static boolean IsLoggedIn() {
        ParentInfoDO info = PlayerUtil.getParentInfo(SquarePandaUnityActivity.instance);
        return info != null;
    }
    public static void GetProfileURL() {
        String url = PlayerUtil.getSelectedPlayer(SquarePandaUnityActivity.instance).getProfileURL();
        SendUnityMessage("profileURLResponse", url);
    }
    public static void Terms() {
        PlayerUtil.showTermsNconditions(SquarePandaUnityActivity.instance);
    }
    public static void Privacy() {
        PlayerUtil.showPrivacyPolicy(SquarePandaUnityActivity.instance);
    }
    public static void Credits() {
        PlayerUtil.showCredits(SquarePandaUnityActivity.instance);
    }
    public static void StartParentalCheckActivity() {
        PlayerUtil.startParentalCheckActivity(SquarePandaUnityActivity.instance, 0);
    }
    public static void Logout() {
        PlayerUtil.logoutUser(SquarePandaUnityActivity.instance);
    }
    public static String GetSelectedPlayer() {
        return PlayerUtil.getSelectedPlayer(SquarePandaUnityActivity.instance).toString();
    }
    public static void ShowAlertWarning(String title, String msg, String btnText, String methodName) {
        Util.showAlertWarning(SquarePandaUnityActivity.mUnityPlayer.getContext(), title, msg, btnText,
                              new android.view.View.OnClickListener(methodName) {
                                  final String val$methodName; 
                                  public void onClick(View v) {
                                      SquarePandaSDK.SendUnityMessage(methodName, "");
                                  }
// 这里好像是我自己整的,当时没太搞明白是怎么回事                                  
                                      {
                                          //private OnClickListener init(String s) { // <<<<<<<<<<<<<<<<<<<< 应该是这行 是 不需要 添加的,我自己弄的
                                          methodName = s;
                                          super();
                                      }
                              }
            );
    }
    public static void ShowAlert(String title, String msg, String btnText1, String btnText2, String methodName1, String methodName2) {
        Util.showAlert(SquarePandaUnityActivity.mUnityPlayer.getContext(), title, msg, Text1, Text2, new android.view.View.OnClickListener(methodName1) {
                final String val$methodName1;
                public void onClick(View v) {
                    SquarePandaSDK.SendUnityMessage(methodName1, "");
                }
                    {
                        super();
                        methodName1 = s;
                    }
            }, new android.view.View.OnClickListener(methodName2) {
                    final String val$methodName2;
                    public void onClick(View v) {
                        SquarePandaSDK.SendUnityMessage(methodName2, "");
                    }
                        {
                            methodName2 = s;
                            super();
                        }
                });
    }
}
\end{minted}
\subsection{SquarePandaUnityActivity.java}
\label{sec-1-4}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
// 这个类折解得很细,比网络上其它安卓SDK与unity的交互写得理深入更底层和细节一点儿
public class SquarePandaUnityActivity
    extends BluetoothBaseActivity { // <<<<<<<<<<<<<<<<<<<< AppCompatActivity
// public abstract class BluetoothBaseActivity extends AppCompatActivity // <<<<<<<<<<<<<<<<<<<< 
//     implements BluetoothCharacteristicListener, LoginListener, DialogInterface.OnDismissListener, PlaysetConnectionListener {
    
    public static final String TAG = "SPUnityActivity";

    private static BluetoothBaseActivity _instance; // <<<<<<<<<< 相当于是,安卓SDK端的实例 reference

    public static UnityPlayer mUnityPlayer; // <<<<<<<<<<<<<<<<<<<< mUnityPlayer UnityPlayerActivity
    public static SquarePandaUnityActivity instance; // <<<<<<<<<< 相当于是,unity游戏端的实例 reference

    private boolean _isScreenLocked;
    private boolean _fromBackground;

    public SquarePandaUnityActivity() {
        _isScreenLocked = false;
        _fromBackground = false;
    }
    protected void onCreate(Bundle savedInstanceState) {
        _isScreenLocked = false;
        requestWindowFeature(1);
        super.onCreate(savedInstanceState);
        if (mUnityPlayer == null) {
            getWindow().setFormat(2);
            mUnityPlayer = new UnityPlayer(this); // <<<<<<<<<< 
            instance = this;
        } else {
            ((ViewGroup)mUnityPlayer.getParent()).removeView(mUnityPlayer);
            UnityPlayer.currentActivity = this;
            instance = (SquarePandaUnityActivity)UnityPlayer.currentActivity;
        }
        setContentView(mUnityPlayer); // <<<<<<<<<< 就是,游戏界面在安卓端的实现,就是这个样子的了 ?
        mUnityPlayer.requestFocus();
    }
    protected void onDestroy() {
        mUnityPlayer.quit(); // <<<<<<<<<< 
        super.onDestroy();
    }
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == 1005)
            SquarePandaSDK.SendUnityMessage("UnlockPermissionResponse", "1");
        else if (resultCode == 1007)
            SquarePandaSDK.SendUnityMessage("UnlockPermissionResponse", "0");
    }
    protected void onSuccessLogoutEvent() {
        SquarePandaSDK.SendUnityMessage("SuccessLogout", "1");
    }
    protected void onPause() {
        super.onPause();
        mUnityPlayer.pause();
    }
    protected void onResume() {
        super.onResume();
        mUnityPlayer.resume();
        if(!_isScreenLocked) {
            if(_fromBackground) {
                if(SquarePandaSDK.IsLoggedIn())
                    PlayerUtil.startSelectPlayerActivity(instance, true, 1);
                _fromBackground = false;
            }
        } else {
            _isScreenLocked = false;
        }
    }
    public void gamePaused(boolean b) {
        SquarePandaSDK.SendUnityMessage("_onSDKScreenOpen", "");
        _isScreenLocked = b;
        _fromBackground = true;
    }
    public void onConfigurationChanged(Configuration newConfig) { // 自己的项目中只涉及到横竖屏的切换,暂时还不想涉及语言的变更
        super.onConfigurationChanged(newConfig);
        mUnityPlayer.configurationChanged(newConfig);
    }
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        mUnityPlayer.windowFocusChanged(hasFocus);
    }
    public boolean dispatchKeyEvent(KeyEvent event) {
        if(event.getAction() == 2)
            return mUnityPlayer.injectEvent(event);
        else
            return super.dispatchKeyEvent(event);
    }

    public boolean onKeyUp(int keyCode, KeyEvent event) {
        return mUnityPlayer.injectEvent(event);
    }
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        return mUnityPlayer.injectEvent(event);
    }
    public boolean onTouchEvent(MotionEvent event) {
        return mUnityPlayer.injectEvent(event);
    }
    public boolean onGenericMotionEvent(MotionEvent event) {
        return mUnityPlayer.injectEvent(event);
    }
    public void batteryLevel(String s) {
        SquarePandaSDK.SendUnityMessage("_onBatteryLevel", s);
    }
    public void availableServices() {}
    protected void didNavigatesToMainMenu() { // 为什么会需要使用这个方法 ?
        SquarePandaSDK.SendUnityMessage("_onSDKScreenClose", "");
    }
    public void didFinishSdkUserConfiguration() {
        SquarePandaSDK.SendUnityMessage("OnZPadFinishSDKUserConfig", "");
    }
    public void didfinishSDKscreenflow() {
        SquarePandaSDK.SendUnityMessage("_onSDKReady", "");
    }
    public void didSelectedChild(PlayerDO player) { // 这里,我大概可以改装一个 onUserLogin之类的回调给游戏端
        PlayerUtil.setSelectedPlayer(instance, player);
        SquarePandaSDK.SendUnityMessage("_onProfileSelected", "");
        SquarePandaSDK.SendUnityMessage("_onSDKScreenClose", "");
    }
}
\end{minted}
\subsection{游戏端SquarePanda.cs: 它充当游戏端的公用API方法,通过内部对ISDK分平台的不同实现,调用 SDK}
\label{sec-1-5}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
public class SquarePanda : MonoBehaviour { // 单例模式接口

    // The sdk calls.
    private ISDK _sdkCalls;
    private static readonly string GO_NAME = "SquarePanda";
    private static SquarePanda _instance;

    // Gets the instance.
    public static SquarePanda Instance {
        get {
            if (_instance == null) {
                _instance = FindObjectOfType<SquarePanda>();
                if (_instance == null)
                    new GameObject().AddComponent<SquarePanda>();
            }
            return _instance;
        }
    }
    // paused is true when the user has oppened one of the square panda screens while in the game screen
    public bool _paused = false;
    // init
    void Awake() {
        if (_instance != null)
            Destroy(gameObject);
        _instance = this;
        gameObject.name = GO_NAME;
        DontDestroyOnLoad(gameObject);
        #if UNITY_EDITOR
            _sdkCalls = new EditorSDK();
        #elif UNITY_ANDROID
            _sdkCalls = new AndroidSDK();
        #elif UNITY_IOS
            _sdkCalls = new IOSSDK();
        #endif
            Debug.Log("[SP SDK] Init()");
        _sdkCalls.Init(); // <<<<<<<<<<<<<<<<<<<< 这里需要一个初始化
        _onSDKScreenOpen(); // 是说,当游戏开始的时候,首先打开SDK
    }
    void OnDestroy() {
        _instance = null;
    }
    // this gets called when an sdk screen is closed
    // will set _paused to false if it wasnt already paused
    private void _onSDKScreenClose() {
        #if UNITY_EDITOR
            return;
        #endif
            _paused = false;
        Debug.Log("sdk is unpausing"); // <<<<<<<<<< 这什么 破烂日志
        if (unpause != null)
            unpause();
    }
    // called when an sdkscreen is opened
    // sets _paused to true
    public void _onSDKScreenOpen() { // 当打开了SDK,要求游戏端暂停
        #if UNITY_EDITOR
            return;
        #endif
            _paused = true;
        if (pause != null)
            pause();
    }
    // squarepanda update loop. Updates leds with a minimum wait time between updates.
    // if editor will allow for user to input letter, places random letter in tray
    void Update() { // <<<<<<<<<<<<<<<<<<<< 游戏端的生命周期调用, 方便游戏里的调试
        #if UNITY_EDITOR
            if (Input.anyKeyDown)
            {
                if (Input.GetKey(KeyCode.Backspace))
                {
                    _lastKeyPressed = "";
                    int index = Random.Range(0, 8);
                    SpawnLetterPressed(index);
                } else if (Input.inputString != "")
                {
                    _lastKeyPressed = Input.inputString.ToUpper();
                    int index = Random.Range(0, 8);
                    SpawnLetterPressed(index);
                }
            }
        #endif
    }
    
    #region _events
        // Occurs when the board charaters are updated.
        public event UnityAction<string[]> OnCharactersUpdated;

    // logs the battery level
    // <param name="level">Level.</param>
    private void _onBatteryLevel(string level) {
        Debug.Log(level);
    }
    // called in response to getting unlock permissions
    // <param name="result">Result.</param>
    private void UnlockPermissionResponse(string result) {
        // 1 success
        // 0 fail
        // -1 canceled
        if (unlockCallback != null) {
            unlockCallback(result == "1");
            unlockCallback = null;
        }
    }
    // callback action for when a new player is selected
    public UnityAction profileSelected;
    // callback from the sdk wrapper that a profile is selected
    private void _onProfileSelected() {
        if (profileSelected != null)
            profileSelected();
    }
    // The unlock callback.
    public UnityAction<bool> unlockCallback;
    // Occurs when sdk screen is oppened.
    public event UnityAction pause;
    // Occurs when sdkscreen is closed.
    public event UnityAction unpause;
    // called when sdk is ready
    private void _onSDKReady() {
        _onSDKScreenClose();
        if (OnPlaysetConnected != null)
            OnPlaysetConnected("");
    }
    // call this when you want to bring up the parental lock screen. pass it a callback for the response
// 忘记细节了,这里大概是一个父母可以锁屏的功能      
    public void spGetUnlockPermission(UnityAction<bool> callback) {
        if (unlockCallback != null)
            return;
        unlockCallback = callback;
        Debug.Log("[SP SDK] spGetUnlockPermission()");
        _sdkCalls.GetUnlockPermission();
    }
    // opens manage playset screen: 游戏中可以开启的设置功能,相当于自己的游戏界面中有个settings按钮方便用户打开登出或是调音量之类的
    public void spManagePlayset() {
        _onSDKScreenOpen();
        Debug.Log("[SP SDK] spManagePlayset()");
        _sdkCalls.ManagePlayset();
    }
    // shows the login screen
    public void spShowLogin() {
        Debug.Log("[SP SDK] spShowLogin()");
        _sdkCalls.ShowLogin();
    }
    // gets if a player is selected
    public bool spIsChildSelected() {
        Debug.Log("[SP SDK] spIsChildSelected()");
        return _sdkCalls.IsChildSelected();
    }
    // shows the credits page that you provided
    public void spShowCredits() {
        //            _onSDKScreenOpen ();
        Debug.Log("[SP SDK] spShowCredits()");
        _sdkCalls.Credits();
    }
    // calls the triggerUpdateOverAir
    public void spTriggerUpdateOverAir() {
        Debug.Log("[SP SDK] spTriggerUpdateOverAir()");
        _sdkCalls.TriggerUpdateOverTheAir();
    }
    // shows the terms and conditions page
    public void spShowTerms() {
        //            _onSDKScreenOpen ();
        Debug.Log("[SP SDK] spShowTerms()");
        _sdkCalls.Terms();
    }
    // shows the privacy policy page
    public void spShowPrivacy() {
        //            _onSDKScreenOpen ();
        Debug.Log("[SP SDK] spShowPrivacy()");
        _sdkCalls.Privacy();
    }
    // returns if the user is logged in
    public bool spIsLoggedIn() {
        Debug.Log("[SP SDK] spIsUserLoggedIn()");
        return _sdkCalls.IsUserLoggedIn();
    }
    // logs the user out. This will always show the parent lock screen and log out if successful
    public void spLogout() {
        #if UNITY_ANDROID
            Debug.Log("[SP SDK] spLogOut()");
        _sdkCalls.Logout();
        #else
            spGetUnlockPermission (logoutCallback);
        #endif
            }
    // the logout callback
    private void logoutCallback(bool b) {
        if (b) {
            _onSDKScreenOpen();
            _sdkCalls.Logout();
        }
    }

    // Called when the user successfully logs out. Only used On android
    public void SuccessLogout() {
        _onSDKScreenOpen();
    }
    // gets the url of the profile picture image used for the child profile
    // <returns>the url for the image to be loaded</returns>
    public void spGetProfileURL(UnityAction<string> response) {
        urlResponse = response;
        Debug.Log("[SP SDK] spGetProfileURL()");
        _sdkCalls.GetProfileURL();
    }
    // the url response action callback
    UnityAction<string> urlResponse;
    // called when the url is recieved
    // <param name="url">URL.</param>
    private void profileURLResponse(string url) {
        if (urlResponse != null) {
            urlResponse(url);
            urlResponse = null;
        }
    }
    // uploads a settings object specified by the game. Saves this on a per child basis
    // <param name="obj">the object containing settings information</param>
    // <param name="fileName">a unique name for your game</param>
    public void spUploadUserSettings(object obj, string fileName) {
        string data = JsonUtility.ToJson(obj);
        Debug.Log("[SP SDK] spUploadUserSettings()");
        _sdkCalls.UploadFileWithName(data, fileName);
    }
    // called when a json string is recieved from the server
    UnityAction<string> jsonResponse;
    // called when trying to get a json string from the server but failed
    UnityAction jsonFail;
    // downlaods user settings from the server based on current selected player. sends a response in the form of a json string to be parsed
    // <param name="fileName">a unique name for your game</param>
    // <param name="response">the response callback</param>
    // <param name="response">the error callback, use to reset to default</param>
    public void spDownloadUserSettings(string fileName, UnityAction<string> response, UnityAction error) {
        jsonResponse = response;
        jsonFail = error;
        _sdkCalls.DownloadFileWithName(fileName);
    }
    // called if file loaded
    // <param name="response">Response.</param>
    public void _onLoadFileSuccess(string response) {
        if (jsonResponse != null) {
            jsonResponse(response);
            jsonResponse = null;
            jsonFail = null;
            return;
        }
    }
    // called if file failed to load
    public void _onLoadFileFail() {
        if (jsonFail != null) {
            jsonFail();
            jsonResponse = null;
            jsonFail = null;
            return;
        }
    }
    
#if UNITY_EDITOR
    // the last key pressed in editor
    string _lastKeyPressed = "";

    // in editor, allows developer to use keyboard in place of the playset, places the letter typed in a random slot, backspace removes a letter form random spot
    private void SpawnLetterPressed(int index) {
        boardChars[index] = _lastKeyPressed;
        if (OnCharactersUpdated != null)
            OnCharactersUpdated(boardChars);
    }
    #endif
}
\end{minted}
\subsection{游戏端ISDK.cs: 定义一个公用接口的目的,是方便ios和安卓等不同平台的实现分平台管理}
\label{sec-1-6}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
public interface ISDK {

    void Init ();
    void ShowLogin ();
    void TriggerUpdateOverTheAir ();
    void Credits ();
    void Terms ();
    void Privacy ();
    void Logout ();
    void GetUnlockPermission ();
    bool IsUserLoggedIn ();
    void GetProfileURL();
    void UploadFileWithName (string data, string name);
    void DownloadFileWithName (string name);
}
\end{minted}
\subsection{游戏端对ISDK接口的实现,是充当桥梁在实现里调用了中介SDK中所定义过的SDK的具体实现方法,从而实现游戏端调用安卓SDK}
\label{sec-1-7}
\begin{minted}[fontsize=\scriptsize,linenos=false]{csharp}
public class AndroidSDK: ISDK { // 游戏端对接口方法的实现,其实现是调用中介SDK中所定义过的类中的具体实现

    private AndroidJavaClass _javaClassVariable = null;
    private AndroidJavaClass _androidSDK {
        get {
            if (_javaClassVariable == null)
                _javaClassVariable = new AndroidJavaClass("com.squarepanda.SquarePandaSDK"); // <<<<<<<<<< 中介SDK中所定义的具体实现的方法类
            return _javaClassVariable;
        }
    }
    public void Init () {
        _androidSDK.CallStatic ("Init");
    }
    public void ShowLogin () {
        _androidSDK.CallStatic ("StartSplashScreenActivity");
    }
    public void TriggerUpdateOverTheAir () {
        _androidSDK.CallStatic ("TriggerUpdateOverTheAir");
    }
    public void Credits () {
        _androidSDK.CallStatic ("Credits");
    }
    public void Terms () {
        _androidSDK.CallStatic ("Terms");
    }
    public void Privacy () {
        _androidSDK.CallStatic ("Privacy");
    }
    public void Logout () {
        _androidSDK.CallStatic ("Logout");
    }
    public void GetUnlockPermission() {
        _androidSDK.CallStatic ("StartParentalCheckActivity");
    }
    public bool IsUserLoggedIn () {
        return _androidSDK.CallStatic<bool>("IsLoggedIn");
    }
    public void UploadFileWithName (string data, string name){
        _androidSDK.CallStatic ("UploadFileWithName", data, name);
    } 
    public void DownloadFileWithName (string name){
        // TODO needs implementation
        _androidSDK.CallStatic ("DownloadFileWithName", name);
    }
    public void GetProfileURL() {
        _androidSDK.CallStatic ("GetProfileURL");
    }
    public AndroidSDK () {}
}
\end{minted}
\subsection{AnddroidManifest.xml: 是游戏端安卓平台配置的Assets\Plugins\Android}
\label{sec-1-8}
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.unity3d.player"
          android:installLocation="preferExternal"
          android:theme="@android:style/Theme.NoTitleBar"
          android:versionCode="11"
          android:versionName="1.1"
          xmlns:tools="http://schemas.android.com/tools">
  <!-- 注意上面的包裹名称 com.unity3d.player -->

  <!-- 这个,这里也是可以设置的 -->
  <!-- Set target sdk version to Lollipop to prevent issues with Marshmallow's runtime permissions. -->
  <uses-sdk android:minSdkVersion="25" android:targetSdkVersion="31"/>

  <supports-screens android:smallScreens="false"
                    android:normalScreens="false"
                    android:largeScreens="true"
                    android:xlargeScreens="true"
                    android:requiresSmallestWidthDp="600" />
  <!-- 权限许可等 -->
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /> 
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.NFC" />

  <!-- activity的名称这里写的是全名 -->
  <application
      android:allowBackup="true"
      android:label="安卓"
      android:supportsRtl="true">
    <activity android:name="com.deepwaterooo.DWUnityActivity"
              android:launchMode="singleTask"
			  android:label="@string/app_name"
			  android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale">
        <meta-data
            android:name="unityplayer.UnityActivity"
            android:value="true"/>
        <meta-data android:name="com.deepwaterooo.DWUnityActivity" android:value="true" />
        <intent-filter>
            <action android:name="android.intent.action.MAIN"/>
            <category android:name="android.intent.category.LAUNCHER"/>
        </intent-filter>
    </activity>
    <!-- 没有搞明白上面两个meta-data是作什么用的,为什么需要,否则找不到类吗? -->
  </application>
</manifest>
\end{minted}

\textasciitilde{}* SDK flow的基本流程设计:
\begin{itemize}
\item 在这里起参考作用的是这个链接:\url{https://blog.csdn.net/u014361280/article/details/91888091}
\begin{itemize}
\item 把里面的几种方法想透,也有试过导出游戏工程在安卓中构建,但是因为一个自己还不是很能理解的bug (就是说运行时,它找不到AOT的相关编译码,有试用mono导和用il2cpp导,都出现同样的bug).后来把这里面的思路想透,直接实现在unity引擎中打.apk包,运行出上面的效果,实现运行出来,感觉很开心.
\end{itemize}
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221207_200732.png}
\begin{itemize}
\item 这里面的小问题包括:当用户正在玩游戏,但感觉音量大了一点儿,想直接去应用中调音量,但是进入安卓SDK,游戏会丢失.这里有个像上份工作中电动车,当用户出去购物时,希望车的配置是被保存保留的.也就是说,(如果可以,)通过操作安卓活动的启动方式,或者是游戏本身为用户帮助用户保存游戏状态,当从安卓SDK中切回来的时候,不是回到游戏的初始界面,而是回到用户离开前的界面.想想这个有什么比较好的实现设计思路
\item 还没有想明白,为什么模仿上上份工作中的项目,不知道是否是因为com.unity3d.UnityPlayerActivity UnityPlayer的改变,没能连通.会花时间再想想原因
\item 现在这个大框架好了之后,就可以顺理成章地去实现小SDK中的各个功能,登录登出,网络请求服务器等
\item 现在所有的挑战就剩对自己来说最难的游戏热更新服务器的设计与实现了

\item 我可以,也已经绝大部分实现了网络上现有的将unity游戏界面作为安卓界面的一部分等相关简单游戏导出安卓后再构建,但涉及到自己项目中的不同是: 项目使用了热更新,会比普通游戏项目填加几个难度
\item 现仍想按照前工作中的一个项目,直接将安卓SDK接入到游戏中,并从游戏端直接构建,不再导出安卓使用Android Studio来构建 
\begin{itemize}
\item 这里需要想的一个问题是:游戏过程中如何从热更新域中退出来,也就是实现游戏过程中的热更新域的多次重入与多次从热更新域中退出来
\end{itemize}
\end{itemize}







\section{Unity 编译 Android 的原理解析和 apk 打包分析}
\label{sec-2}
\begin{itemize}
\item 最近由于想在Scene的脚本组件中，调用Android的Activity的相关接口，就需要弄明白Scene和Activity的实际对应关系，并对Unity调用Android的部分原理进行了研究。
\item 本文主要探讨Scene和Activity之间的关系，以及Unity打包apk和Android studio打包apk的差别在什么地方？找到这种差别之后，可以怎么运用起来？
\item 本文需要用到的工具：
\begin{itemize}
\item Android反编译工具——apktool
\item Android studio自带的反编译功能
\end{itemize}
\end{itemize}
\subsection{一、将Unity的Scene编译成apk，apk的程序入口会是什么？}
\label{sec-2-1}
\begin{itemize}
\item 新建一个Unity项目，创建一个Scene，将Unity工程编译打包成apk。
\item 对编译出来的apk，利用apktool进行反编译：apktool d unityTest.apk
\item 得到的AndroidManifest文件如下：
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<manifest
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:installLocation="preferExternal"
    package="com.xfiction.p1"
    platformBuildVersionCode="25"
    platformBuildVersionName="7.1.1">

  <supports-screens
      android:anyDensity="true"
      android:largeScreens="true"
      android:normalScreens="true"
      android:smallScreens="true"
      android:xlargeScreens="true"/>

  <application
      android:banner="@drawable/app_banner"
      android:debuggable="false"
      android:icon="@drawable/app_icon"
      android:isGame="true"
      android:label="@string/app_name"
      android:theme="@style/UnityThemeSelector">

    <activity android:name="com.unity3d.player.UnityPlayerActivity" 

        android:configChanges="locale|fontScale|keyboard|keyboardHidden|mcc|mnc|navigation|orientation|screenLayout|screenSize|smallestScreenSize|touchscreen|uiMode"
        android:label="@string/app_name"
        android:launchMode="singleTask"
        android:screenOrientation="fullSensor">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
      </intent-filter>
      <meta-data android:name="unityplayer.UnityActivity" android:value="true"/>
    </activity>
  </application>
  <uses-feature android:glEsVersion="0x00020000"/>
  <uses-feature android:name="android.hardware.touchscreen" android:required="false"/>
  <uses-feature android:name="android.hardware.touchscreen.multitouch" android:required="false"/>
  <uses-feature android:name="android.hardware.touchscreen.multitouch.distinct" android:required="false"/>
</manifest>
\end{minted}
\begin{itemize}
\item 由该AndroidManifest文件可知，系统仍然存在主Activity，名字为com.unity3d.player.UnityPlayerActivity。
\item 言下之意，编译只包含Scene的Unity工程，打包成Android apk，会以com.unity3d.player.UnityPlayerActivity作为主程序入口，那么问题来了，Scene如何加载显示到这个UnityPlayerActivity呢？
\end{itemize}
\subsection{二、UnityPlayerActivity如何加载Unity中的Scene？}
\label{sec-2-2}
\subsubsection{UnityPlayerActivity}
\label{sec-2-2-1}
\begin{itemize}
\item 这个就要从UnityPlayerActivity源码入手了，Android工程中使用UnityPlayerActivity需要依赖到Unity的Android插件classes.jar（位于Unity安装目录，可以用everything软件查找查找得到），对其进行反编译得到UnityPlayerActivity的部分源码：
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
public class UnityPlayerActivity extends Activity {
    protected UnityPlayer mUnityPlayer;
    protected void onCreate(Bundle var1) {
        this.requestWindowFeature(1);
        super.onCreate(var1);
        this.getWindow().setFormat(2);
        this.mUnityPlayer = new UnityPlayer(this);

        this.setContentView(this.mUnityPlayer); // <<<<<<<<<<<<<<<<<<<< 最终的界面显示需要依赖到UnityPlayer的实例

        this.mUnityPlayer.requestFocus();
    }
}
\end{minted}
\begin{itemize}
\item 虽然经过混淆，看起来比较费劲，但从代码this.setContentView(this.mUnityPlayer)可以看出，最终的界面显示需要依赖到UnityPlayer的实例。另外由于Google也做了一套Unity VR的SDK，与UnityPlayerActivity相对应的类，就是GoogleUnityActivity，下面也对它进行分析。
\end{itemize}
\subsubsection{从GoogleUnityActivity.java再入手分析}
\label{sec-2-2-2}
\begin{itemize}
\item GoogleUnityActivity是google推出的VR SDK中，用于实现Unity Activity的类，通过google查询其源码发现：1. GoogleUnityActivity.java实际上的布局文件activity\_main.xml
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >
    <FrameLayout
        android:id="@+id/android_view_container"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="@android:color/transparent" />
</FrameLayout>
\end{minted}
\begin{itemize}
\item 布局文件中没有具体的内容，只包含一个FrameLayout布局。
\end{itemize}
\subsubsection{重点看GoogleUnityActivity的onCreate函数：}
\label{sec-2-2-3}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
public class GoogleUnityActivity   extends Activity
    implements ActivityCompat.OnRequestPermissionsResultCallback {
    protected void onCreate(Bundle savedInstanceState) {
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main); // <<<<<<<<<<<<<<<<<<<< 这里是说可能会有两三种不同的实现方式吗?
        setContentView(R.id.activity_main.xml)

        mUnityPlayer = new UnityPlayer(this);
        if (mUnityPlayer.getSettings().getBoolean("hide_status_bar", true)) {
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                    WindowManager.LayoutParams.FLAG_FULLSCREEN);
        }
        ((ViewGroup) findViewById(android.R.id.content)).addView(mUnityPlayer.getView(), 0);
        mUnityPlayer.requestFocus();
    }
}
\end{minted}
\begin{itemize}
\item mUnityPlayer作为FrameLayoutView加入到view集合中进行显示，注意这里查找的id是android.R.id.content。根据官方对这个id的解释：android.R.id.content gives you the root element of a view, without having to know its actual name/type/ID. Check out Get root view from current activity
\item 由此可见，GoogleUnityActivity的实现原理，是创建一个只包含FrameLayout的空的帧布局，随后通过addView将UnityPlayer中的View加载到GoogleUnityActivity中进行显示。
\item 看起来跟UnityPlayerActivity有异曲同工之妙，两者牵涉的类都是UnityPlayer。
\end{itemize}
\subsubsection{UnityPlayer究竟是一个什么类呢？}
\label{sec-2-2-4}
\begin{itemize}
\item 对classes.jar包进行反编译得到UnityPlayer的部分代码：
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
public class UnityPlayer extends FrameLayout implements com.unity3d.player.a.a {
    public static Activity currentActivity = null;
    public UnityPlayer(ContextWrapper var1) {
        super(var1);
        if(var1 instanceof Activity) {
            currentActivity = (Activity)var1;
        }
    }
    public View getView() {
           return this;
    }
    public static native void UnitySendMessage(String var0, String var1, String var2);
    private final native boolean nativeRender();
    public void onCameraFrame(final com.unity3d.player.a var1, final byte[] var2) {
        final int var3 = var1.a();
        final Size var4 = var1.b();
        this.a(new UnityPlayer.c((byte)0) {
            public final void a() {
            UnityPlayer.this.nativeVideoFrameCallback(var3, var2, var4.width, var4.height);
                var1.a(var2);
            }
        });
    }
}
\end{minted}
\begin{itemize}
\item 从代码中可以发现：
\item UnityPlayer实际上是继承于FrameLayout；
\item 并且自带一个currentActivity的成员变量，在构造函数中，直接传入Activity的相关参数；
\item 在getView函数中直接返回该FrameLayout；
\item GoogleUnityActivity通过UnityPlayer的构造函数，将其context传递给UnityPlayer，并赋值给其成员变量currentActivity。
\item 由于UnityPlayer类做了混淆，关于渲染的核心功能也封装在native代码中，关于Scene转换到到UnityPlayer作为FrameLayout，只能做一个简单的推测：通过调用Android的GL渲染引擎，在native层进行渲染，并同步到FrameLayout在UnityPlayerActivity上进行显示。
\end{itemize}
\subsection{三、 如何将Scene显示在自定义的Activity当中(这里最好能找个真正的例子参考一下)}
\label{sec-2-3}
\begin{itemize}
\item 从以上研究的内容可知，假如要从要实现将Scene显示在固定的Activity当中，则需要对Activity的oncreate部分的countview和unityplayer进行处理。最简单的方法是写一个直接继承于UnityPlayerActivity或GoogleUnityActivity的类，并在类中写所需要的Unity调用Android的方法。这样Scene就会加载在特定的Activity当中，Unity c\#通过获取currentActivity变量就可以获取到该Activity，并调用其中的函数。
\end{itemize}
\subsection{四、 Unity Android 插件需要注意的问题}
\label{sec-2-4}
\begin{itemize}
\item Android studio工程包含多个module的依赖，则需要将对应的module编译的插件一起拷贝Plugins/Android/lib目录当中。
\item 在第一步骤下，可以直接删除打包后的aar library目录，尤其里面假如带有unity的Android插件classesjar，否则会编译报错。
\item 多个module编译的时候，注意manifest lablel相关设置，另外就是build.gradle的minSDKVersion信息。否则会出现manifest merger失败的错误。
\item 关于Unity的Android Manifest文件合并：Unity编写一个Scene，Android studio写一个包含主Activity的aar包，放在Plugins/Android目录当中。用Unity编译apk出来之后，反编译他的AndroidManifest文件,两个主Activity，默认显示包含Scene的Activity。解决方法：Unity的Manifest文件合并，把一个manifest放到Plugins/Android目录下，就不会合并manifest了。
\end{itemize}
\subsection{五、Unity打包Android apk的结构探究}
\label{sec-2-5}
\begin{itemize}
\item 由于Unity开发Android时，常常设计到Unity + Visual和Android studio的环境切换，Unity的开发往往会更快一些，更多的是Android java侧的代码编写和调试。
\item 这种情况时，有没有一种方法，能够将Unity编译好的Unity Scene和c\#相关文件，放到Android studio中进行打包，从而实现直接在Android studio中进行调试？
\item 方法原理倒是很简单，通过对比Unity打包的apk，与普通的Android apk的文件差别，找出Unity文件存放的目录，随后对应存放到Android studio工程目录中，最后通过Android studio完成对Unity相关文件的打包。
\item 首先将apk添加zip的后缀，方便用beyond compare进行对比：
\item 发现只是多了assert/bin目录，在这个目录之下，可以看到unity相关dll库
\item 将该文件，拷贝到Android studio工程的src/main/assert目录之下；
\item 在Android studio调试时，可以将aar library工程设置为app工程，这样就可以编译apk运行到手机了。
\item 用Android studio对该工程进行编译，发现assert/bin目录成功被打包进去。
\item 直接apk install 运行，可以看到跟Unity编译打包的apk，是相同的效果。
\item 相反，假如Android工程调试好之后，则直接编译成app模式修改成library模式，进行build之后，就会生成aar库，此时将aar库拷贝到Plugins/Android/lib目录当中，注意要删除aar库中的assert/bin，因为这个目录是我们先前从Unity拷贝过去的，假如不删除，在unity里面会出现重复打包导致的文件冲突的情况。
\item 由于当将Unity打包之后的bin目录拷贝到Android studio工程之后，Android studio此时是一个library工程，需要转换为app工程。关于这其中涉及到的Android studio library和app的转换，通过设置build.gradle文件来实现：
\item app模式：apply plugin: 'com.android.application'
\item library模式：apply plugin:   'com.android.library'
\item 不过在设置这两种模式时，需要注意applicationId "com.example.yin.myapplication"的设置，假如是library模式，则需要直接注释掉。
\item 假如Android的java部分重新调试好之后，重新将app模式改成library模式，进行build，将生成的aar包，拷贝到Unity Android Plugin目录中，就可以直接在Unity看运行效果了。 \textbf{不过一定要记得删除Android studio打包的aar文件里面的assert/bin目录，以防止在Unity中重复打包。}
\end{itemize}
\subsection{四、结论：}
\label{sec-2-6}
\begin{itemize}
\item Unity中的Scene在Android中，其实对应于Activity的FrameLayout，每个Scene的运行都有其Activity环境，通过currentActivity变量可以获取得到。
\item 要实现自定义的Activity能够具备直接加载Scene的功能，则需要其继承于UnityPlayerActivity或者GoogleUnityActivity，再或者，直接自定义实现UnityActivity类。
\item 提升Unity+Android Plugin项目开发效率的方法：● 直接将Unity打包的apk中的assert/bin目录拷贝到Android studio工程的src/main/assert目录当中，并且将Android工程配置成app模式，就可以直接在Android studio上面，对整个Unity+android plugin的工程进行调试。● Android studio部分调试好之后，需要修改build.gradle文件，重新将app模式修改为library模式，编译出aar包文件，删除原来拷贝过来的unity部分，放入到unity的Plugins/Android/lib目录下进行使用即可。
\end{itemize}

\section{Unity构建安卓原理详解}
\label{sec-3}
\begin{itemize}
\item 构建系统
\item Unity 支持两个 Android 构建系统：\_\_Gradle\_\_ 和 Internal。
\item Android 构建过程所涉及的步骤如下：
\begin{itemize}
\item 准备和构建 Unity 资源。
\item 编译脚本。
\item 处理插件。
\item 将资源拆分为放入 APK 和 OBB 的各个部分（如果已选择 \_\_Split Application Binary\_\_）。
\item 使用 AAPT 实用程序构建 Android 资源（仅限内部构建）。
\item 生成 Android 清单。
\item 将库清单合并到 Android 清单中（仅限内部构建）。
\item 将 Java 代码编译为 Dalvik 可执行文件格式 (DEX)（仅限内部构建）。
\item 构建 IL2CPP 库（如果已选择 \_\_IL2CPP Scripting Backend\_\_）。
\item 构建并优化 APK 和 OBB 包。
\end{itemize}
\item Gradle 构建系统
\begin{itemize}
\item Gradle 构建系统使用 Gradle 来构建 APK 或以 Gradle 格式导出项目，然后可以将其导入 Android Studio。选择此构建系统时，Unity 将执行与 Internal 构建系统相同的步骤，但不包括使用 AAPT 进行资源编译、合并清单以及运行 DEX。然后，Unity 生成 build.gradle 文件（以及其他所需的配置文件），并调用 Gradle 可执行文件，在此过程中向其传递任务名称和工作目录。最后，由 Gradle 构建 APK。
\item 有关更多详细信息，请参阅 Gradle for Android。
\end{itemize}
\item Internal 构建系统
\begin{itemize}
\item Internal 构建系统使用 Android SDK 实用程序创建 APK，从而构建并优化 APK 和 OBB 包。
\end{itemize}
\end{itemize}

\section{Unity是怎么打包APK文件的}
\label{sec-4}
\begin{itemize}
\item 在Unity里面有几个特殊的文件夹是跟打包APK有关的。首先我们就来了解一下，这些文件夹里面的内容是经历了哪些操作才被放到APK里面的呢？
\item 在Unity的Assets目录下，Plugins/Android无疑是其中的重中之重，首先我们先来看一个常见的Plugins/Android目录是什么样子的。
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{tex}
-Android
-- ApolloBase
-- ApolloPlugins
-- assets
-- libs
-- res
-- AndroidManifest.xml
\end{minted}
\begin{itemize}
\item 后面的四个是Android工程的文件。前面两个文件夹是我们引用的第三方库，他们也会被打包到APK中。我们这个时候如果点进去前两个文件夹，我们会发现他们的目录结构跟Android这个目录也很像，大概是一下这个样子的。
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{tex}
-ApolloPlugins
-- libs
-- res
-- AndroidManifest.xml
-- project.properties
\end{minted}
\begin{itemize}
\item 比较上下两层的目录接口我们可以发现有很多相似的部分，如：libs、res、assets文件夹以及AndroidManifest.xml文件。这些其实都是一个标准的Android项目的所需要的文件。Unity自带的Android打包工具的作用就是把上述这几个文件夹里面的内容以固定的方式组织起来压缩到APK文件里面。
\end{itemize}
\subsection{Android打包工具都会做什么样的操作。}
\label{sec-4-1}
\begin{itemize}
\item ● \textbf{libs文件夹里面有很多.jar文件} ，以及被放在固定名字的文件夹里面的.so文件。*.jar文件是Java编译器把.java代码编译后的文件，Android在打包的时候会把项目里面的所有jar文件进行一次合并、压缩、重新编译变成classes.dex文件被放在APK根目录下。当应用被执行的时候Android系统内的Java虚拟机（Dalvik或者Art），会去解读classes.dex里面的字节码并且执行。把众多jar包编译成classes.dex文件是打包Android应用不可或缺的一步。
\begin{itemize}
\item 看到这里有人可能会想不对啊，这一步只将jar包打成dex文件，那之前的java文件生成jar文件难道不是在这一步做吗？没错，这里用的jar包一般是由其他Android的IDE生成完成后再拷贝过来的。本文后面的部分会涉及到怎么使用Android的IDE并且生成必要的文件。
\end{itemize}
\item ● \textbf{libs文件夹的}.so文件* 则是可以动态的被Android系统加载的库文件，一般是由C/C++撰写而成然后编译成的二进制文件。要注意的是，由于实际执行这些二进制库的CPU的架构不一样，所以同样的CC++代码一般会针对不同的CPU架构生成几分不同的文件。这就是为什么libs文件夹里面通常都有armeabi-v7a、armeabi、x86等几个固定的文件夹，而且里面的.so文件也都是有相同的命名方式。Java虚拟机在加载这些动态库的时候会根据当前CPU的架构来选择对应的so文件。有时候这些so文件是可以在不同的CPU架构上执行的，只是在不对应的架构上执行速度会慢一些，所以当追求速度的时候可以给针对每个架构输出对应的so文件，当追求包体大小的时候输出一个armeabi的so文件就可以了。
\item ● \textbf{assets文件夹} ，这个里面的东西最简单了，在打包APK的时候，这些文件里面的内容会被原封不动的被拷贝到APK根目录下的assets文件夹。这个文件夹有几个特性。
\begin{itemize}
\item √ 里面的文件基本不会被Android的打包工具修改，应用里面要用的时候可以读出来。
\item √ 打出包以后，这个文件夹是只读的，不能修改。
\item √ 读取这个文件夹里面的内容的时候要通过特定的Android API来读取，参考getAssets()。
\item √ 基于上述两点，在Unity中，要读取这部分内容要通过WWW来进行加载。
\item 除了Plugins/Android内的所有assets文件夹里面的文件会连同StreamingAssets目录下的文件一起被放到APK根目录下的assets文件夹。
\end{itemize}
\item ● \textbf{res文件夹} 里面一般放的是xml文件以及一些图片素材文件。xml文件一般来说有以下几种：
\begin{itemize}
\item √ 布局文件，被放在res中以layout开头的文件夹中，文件里描述的一般都是原生界面的布局信息。由于Unity游戏的显示是直接通过GL指令来完成的，所以我们一般不会涉及到这些文件。
\item √ 字符串定义文件，一般被放到values文件夹下，这个里面可以定义一些字符串在里面，方便程序做国际
\item 化还有本地化用。当然有时候被放到里面的还有其他xml会引用到的字符串，一般常见的是app的名称。
\item √ 动画文件，一般定义的是Android原生界面元素的动画，对于Unity游戏，我们一般也不会涉及他。
\item √ 图片资源，一般放在以drawable为开头的文件夹内。这些文件夹的后缀一般会根据手机的像素密度来来进行区分，这样我们可以往这些文件夹内放入对应像素密度的图片资源。
\item 例如后缀为ldpi的drawable文件夹里面的图片的尺寸一般来说会是整个系列里面最小的，因为这个文件夹的内容会被放到像素密度最低的那些手机上运行。而一般1080p或者2k甚至4k的手机在读取图片的时候会从后缀为xxxxhdpi的文件夹里面去读，这样才可以保证应用内的图像清晰。图片资源在打包过程中会被放到APK的res文件夹内的对应目录。
\item √ Android还有其他一些常见的xml文件，这里就不一一列举了。
\item res文件夹下的xml文件在被打包的时候会被转换成一种读取效率更高的一种特殊格式（也是二进制的格式），命名的时候还是以xml为结尾被放到APK包里面的res文件夹下，其目录结构会跟打包之前的目录结构相对应。
\item 除了转换xml之外，Android的打包工具还会把res文件夹下的资源文件跟代码静态引用到的资源文件的映射给建立起来，放到APK根目录的resources.arsc文件。这一步可以确保安卓应用启动的时候可以加载出正确的界面，是打包Android应用不可或缺的一步。
\end{itemize}
\item ● \textbf{AndroidManifest.xml} ，这份文件太重要了，这是一份给Android系统读取的指引，在Android系统安装、启动应用的时候，他会首先来读取这个文件的内容，分析出这个应用分别使用了那些基本的元素，以及应该从classes.dex文件内读取哪一段代码来使用又或者是应该往桌面上放哪个图标，这个应用能不能被拿来debug等等。在后面的部分会有详细解释。打包工具在处理Unity项目里面的AndroidManifest文件时会将所有AndroidManifest文件的内容合并到一起，也就是说主项目引用到的库项目里面如果也有AndroidManifest文件，都会被合并到一起。这样就不需要手动复制粘贴。需要说明的是，这份文件在打包Android程序的时候是必不可少的，但是在Unity打包的时候，他会先检查Plugins目录下有没有这份文件，如果没有就会用一个自带的AndroidManifest来代替。此外，Unity还会自动检查项目中AndroidManifest里面的某些信息是不是默认值，如果是的话，会拿Unity项目中的值来进行替换。例如，游戏的App名称以及图标等。
\item ● \textbf{project.properties} ，这份文件一般只有在库项目里面能看得到，里面的内容极少，就只有一句话android.library=true。但是少了这份文件Android的打包工具就不会认为这个文件夹里面是个Android的库项目，从而在打包的时候整个文件夹会被忽略。这有时候不会影响到打包的流程，打包过程中也不会报错，但是打出的APK包缺少资源或者代码，一跑就崩溃。关于这份文件，其实在Unity的官方文档上并没有详细的描述（因为他实际上是Android项目的基础知识），导致很多刚刚接触Unity-Android开发的开发者在这里栽坑。曾经有个很早就开始用Unity做Android游戏的老前辈告诉我要搞定Unity中的Android库依赖的做法是用Eclipse打开Plugins/Android文件夹，把里面的所有的项目依赖处理好就行了。殊不知这样将Unity项目跟Eclipse项目耦合在一起的做法是不太合理的，会造成Unity项目开启的时候缓慢。
\item ● \textbf{其他文件夹例如aidl以及jni} 在Unity生成APK这一步一般不会涉及到，这里不展开。
\item 看到了上述介绍的Unity打包APK的基础知识我们知道了往Plugins/Android目录下放什么样的文件会对APK包产生什么样的影响。但是实际上上述的内容只是着重的讲了Unity是怎么打包APK，所以接下来会简述一下打包这个步骤到底是怎么完成的。
\item \textbf{Android提供了一个叫做aapt的工具，这个工具的全称是Android Asset Packaging Tool} ，这个工具完成了上述大部分的对资源文件处理的工作，而Unity则是通过对Android提供的工具链（Android Build Tools）的一系列调用从而完成打包APK的操作。这里感觉有点像我们写了个bat/bash脚本，这个脚本按照顺序调用Android提供的工具一样。在一些常见的Android IDE里面，这样的“bat/bash脚本”往往是一个完整的构建系统。最早的Android IDE是Eclipse，他的构建系统是Ant，是基于XML配置的构建系统。后来Android团队推出了Android专用的IDE——Android Studio（这个在文章后面会有详述），他的构建系统则是换成了gradle，从基于xml的配置一下子升级到了语言（DSL, Domain Specific Language）的层级，给使用Android Studio的人带来更多的弹性。
\item 写到这里我想很多人都清楚了要怎么把Android的SDK/插件放到Unity里面并且打包到Unity里面。这时候应该有人会说，光会放这些文件不够啊，我还需要知道自己怎么写Android的代码并且输出相应的SDK/插件给Unity使用啊。1
\end{itemize}

\section{unity3d 打包发布篇--MONO和IL2CPP原理}
\label{sec-5}
\begin{itemize}
\item 两种方式打包以后的项目目录结构
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094114.png}
\subsection{Mono方面}
\label{sec-5-1}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094154.png}
\begin{itemize}
\item mono是一款开源、免费、可定制的跨平台.NET运行环境。由于.net只能在windows，mono相当于是一个.net CLR的跨平台变种，就是为了解决跨平台的移植问题。
\item 在运行IL方面上，热更也需要基于JIT，安卓支持即时编译JIT，虽然热更方便，但如果代码中有病毒木马，也一样编译。
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094222.png}
\subsection{IL2CPP：}
\label{sec-5-2}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094415.png}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094520.png}
\begin{itemize}
\item 最早IOS是支持MONO，但MONO只能支持32位，而且2016年后苹果要求必须64位。
\item IOS出于安全考虑，不允许JIT，而且因为禁止脚本为动态分配内存赋予执行权限，所以使用反射会有限制，只能静态编译，只能FULL AOT或者il2cpp，热更相对于安卓就比较麻烦。
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221125_094643.png}
\begin{itemize}
\item 在有泛型的情况下，代码很可能会报错，因为泛型T只有在执行的时候才知道自己的类型，属于动态的，所以静态编译会直接跳过这句代码，在运行的时候就会报错：尝试JIT的error.
\end{itemize}

\section{一个SDK的整合步骤，再消化理解一下}
\label{sec-6}
\begin{itemize}
\item 一.把SDK文件放到游戏安卓主工程的libs下
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153025.png}
\begin{itemize}
\item 二.安卓主工程中的build.gradle的修改,主要是添加必要的依赖包
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153107.png}
\begin{itemize}
\item 三.把游戏的主启动活动申明清楚: 这里好像还没有弄明白是在哪里申明

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153212.png}
\begin{itemize}
\item 如果是在.aar SDK中的字符串申明会报错?
\end{itemize}
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221226_151633.png}
　
\begin{itemize}
\item 四.还需要游戏ID ?
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153240.png}
\begin{itemize}
\item 五.同一个公司同一套SDK,类似游戏的背景图片修改
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153320.png}
\begin{itemize}
\item 六.是production, 还是debug呢?
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153405.png}
\begin{itemize}
\item 七.其它单个某公司SDK相关的
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_153542.png}
\section{安卓基本支持库结构}
\label{sec-7}

\includegraphics[width=.9\linewidth]{./pic/notes_20221220_223427.png}

\section{构建纪录: 安卓SDK integration into unity games}
\label{sec-8}
\begin{itemize}
\item 将所有的包裹都转成了androidX,倒出Mono在Android Studio中构建,(IL2CPP我刚才测好像是不行),其它细节修改:主要是为了解决安卓12启动黑并的问题
\begin{itemize}
\item 参考:\url{https://blog.csdn.net/m0_73817060/article/details/127112566}
\end{itemize}
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221226_202949.png}
\begin{itemize}
\item 我照它说的在方法最头第一行加了下面的
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{tex}
getstatic android/os/Build$VERSION/SDK_INT I
bipush 31
if_icmplt 5
return
\end{minted}
\begin{itemize}
\item 源码后来变成了: UnityPlayer.class
\begin{minted}[fontsize=\scriptsize,linenos=false]{java}
protected void addPhoneCallListener() {
    if (VERSION.SDK_INT < 31) {
        this.i = true;
        this.k.listen(this.j, 32);
    }
}
\end{minted}
\item \url{https://www.jianshu.com/p/2ce130a96b25}
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/notes_20221226_203239.png}
\begin{itemize}
\item build.gradle:
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{groovy}
implementation 'androidx.work:work-runtime:2.7.1'
\end{minted}
\begin{itemize}
\item AndroidManifest.xml
\end{itemize}
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/>
\end{minted}
\begin{itemize}
\item 完整的文件被我变成了是:
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.deepwaterooo.tetris"
          xmlns:tools="http://schemas.android.com/tools"
          android:theme="@android:style/Theme.NoTitleBar"
          android:versionCode="1"
          android:versionName="1.0">
  <!-- package="com.unity3d.UnityPlayerActivity" -->

  <uses-sdk android:minSdkVersion="26"
            android:targetSdkVersion="31" />

  
  <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.NFC" />
  <uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/>  

  <application
      android:label="@string/app_name"
      android:theme="@style/Theme.AppCompat.DayNight"
      android:allowBackup="true"
      tools:replace="android:allowBackup"
      android:isGame="false"
      android:largeHeap="true"
      android:process=":raadidcard"
      android:icon="@mipmap/app_icon">

    <activity android:name="com.deepwaterooo.DWUnityActivity"
              android:label="@string/app_name"
              android:launchMode="singleTask"
              android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
              android:exported="true">
      <meta-data android:name="unityplayer.UnityActivity" android:value="true" />
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
    <!-- <meta-data android:name="android.app.lib_name" android:value="unity" /> -->
    <!-- <meta-data android:name="com.deepwaterooo.DWUnityActivity" android:value="true" /> -->
    <activity android:name="com.deepwaterooo.DWSDK"></activity>

    <meta-data android:name="unity.build-id" android:value="6f3b9a05-74e8-4906-ab7d-f9abb9791268" />
    <meta-data android:name="unity.splash-mode" android:value="0" />
    <meta-data android:name="unity.splash-enable" android:value="True" />
  </application>
  <uses-feature android:glEsVersion="0x00020000" />
  <uses-feature android:name="android.hardware.gamepad" />
  <!-- <uses-feature android:name="android.hardware.vulkan" android:required="false" /> -->
  <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
  <uses-feature android:name="android.hardware.touchscreen.multitouch" android:required="false" />
  <uses-feature android:name="android.hardware.touchscreen.multitouch.distinct" android:required="false" />
</manifest>
\end{minted}

\item 在整合安卓SDK .aar .jar之前我曾经有几个小测试项目都可以在unity中internally 构建和运行成功
\item 今天主要解决了安卓SDK .aar .jar整合入unity游戏之后,unity中internally构建的问题,过程中出现过无数的bug,但是现可以成功构建
\item 在整合安卓SDK .aar .jar之后，可以成功构建.apk,但运行时会出现找不到启动类，感觉为我的.jar包打得不够理想，reference的类好像没有包括进去
\item 解决过之前找不到启动类的问题,可是这里整合了安卓SDK之后又有点儿不同
\item 计划按照以下的思路来debug解决这个问题:
\begin{itemize}
\item 1.反编译生成的.apk文件,查找相关的启动类是否被成功打入包,能否被正确读取(如果不能有效解决,会试下面的第2种方法)
\item 2.将源参考项目的老旧构建版本更新到与自己现项目v7-25.0.0 同步,并构建.在重构更新源项目并打包运行的过程中,试图找出自己项目中可能存在或是缺失的部分
\item 再按上面两条不同途径得出的经验来把这个接通
\end{itemize}
\item 今天构建项目构建了一天,就在体会昨天找不类可能是因为安卓包没有真正包括进去,今天
\end{itemize}
\subsection{按照源旧参考项目的写法,它的视图是用 filament渲染的,这里的原理我还没有机会学习,没有弄懂}
\label{sec-8-1}
\begin{itemize}
\item 当我把配置按源项目写成是:
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<activity android:name="com.deepwaterooo.DWUnityActivity"
          android:launchMode="singleTask"
          android:label="@string/app_name"
          android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
          android:exported="true">
  <!--这里记得加入这个参数，不然会报错 下面一行,模仿补的-->
  <meta-data android:name="android.app.lib_name" android:value="unity" />
  <meta-data android:name="com.deepwaterooo.DWUnityActivity" android:value="true"/>
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
</activity>
\end{minted}
\item 接下来就一定会找不到类：
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/readme_20221218_220636.png}
\subsection{按照自己后来参考的写法,有点儿像先前的项目,再去看安卓SDK的调用}
\label{sec-8-2}
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<activity android:name="com.unity3d.player.UnityPlayerActivity"
          android:launchMode="singleTask"
          android:label="@string/app_name"
          android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
          android:exported="true">
  <!--这里记得加入这个参数，不然会报错 下面一行,模仿补的-->
  <meta-data android:name="unityplayer.UnityActivity" android:value="true" />
  <intent-filter>
    <action android:name="android.intent.action.MAIN" />
    <category android:name="android.intent.category.LAUNCHER" />
  </intent-filter>
</activity>
\end{minted}
\begin{itemize}
\item 这样的话,游戏端可以正常运行,去检查安卓SDK 的调用情况日志等,现在是找不到我安卓.aar包中的类
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/readme_20221218_230256.png}
\begin{itemize}
\item 到今天晚上能够再次把这些构建好了,明天就可以看进这个问题了.爱表哥,爱生活,一定要嫁给偶亲爱的表哥!!!
\item Mono 包的话:
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/readme_20221220_151236.png}
\begin{minted}[fontsize=\scriptsize,linenos=false]{tex}
D MainActivity: StartSplashScreenActivity() 
E Unity   : AndroidJavaException: java.lang.NoClassDefFoundError: Failed resolution of: Lcom/deepwaterooo/sdk/activities/BaseActivity;
E Unity   : java.lang.NoClassDefFoundError: Failed resolution of: Lcom/deepwaterooo/sdk/activities/BaseActivity;
E Unity   : 	at java.lang.Class.classForName(Native Method)
E Unity   : 	at java.lang.Class.forName(Class.java:454)
E Unity   : 	at java.lang.Class.forName(Class.java:379)
E Unity   : 	at com.unity3d.player.UnityPlayer.nativeRender(Native Method)
E Unity   : 	at com.unity3d.player.UnityPlayer.c(Unknown Source:0)
E Unity   : 	at com.unity3d.player.UnityPlayer$e$2.queueIdle(Unknown Source:72)
E Unity   : 	at android.os.MessageQueue.next(MessageQueue.java:404)
E Unity   : 	at android.os.Looper.loopOnce(Looper.java:186)
E Unity   : 	at android.os.Looper.loop(Looper.java:313)
E Unity   : 	at com.unity3d.player.UnityPlayer$e.run(Unknown Source:32)
E Unity   : Caused by: java.lang.ClassNotFoundException: com.deepwaterooo.sdk.activities.BaseActivity
E Unity   : 	... 10 more
E Unity   :   at UnityEngine.AndroidJNISafe.CheckException () [0x00000] in <filename unknown>:0 
E Unity   :   at UnityEngine.AndroidJNISafe.CallStaticVoidMethod (IntPtr clazz, IntPtr method
E Unity   : NullReferenceException: Object reference not set to an instance of an object
E Unity   :   at GestureRecognizerTS`1[T].CanBegin (.T gesture, IFingerList touches) [0x00000] in <filename unknown>:0 
E Unity   :   at LongPressRecognizer.CanBegin (.LongPressGesture gesture, IFingerList touches) [0x00000] in <filename unknown>:0 
E Unity   :   at GestureRecognizerTS`1[T].UpdateExclusive () [0x00000] in <filename unknown>:0 
E Unity   :   at GestureRecognizerTS`1[T].Update () [0x00000] in <filename unknown>:0 
E Unity   :  
E Unity   : (Filename:  Line: -1)
\end{minted}
\begin{itemize}
\item IL2CPP 包
\end{itemize}

\includegraphics[width=.9\linewidth]{./pic/readme_20221220_151607.png}
\begin{minted}[fontsize=\scriptsize,linenos=false]{tex}
D MainActivity: StartSplashScreenActivity() 
E Unity   : AndroidJavaException: java.lang.NoClassDefFoundError: Failed resolution of: Lcom/deepwaterooo/sdk/activities/BaseActivity;
E Unity   : java.lang.NoClassDefFoundError: Failed resolution of: Lcom/deepwaterooo/sdk/activities/BaseActivity;
E Unity   : 	at java.lang.Class.classForName(Native Method)
E Unity   : 	at java.lang.Class.forName(Class.java:454)
E Unity   : 	at java.lang.Class.forName(Class.java:379)
E Unity   : 	at com.unity3d.player.UnityPlayer.nativeRender(Native Method)
E Unity   : 	at com.unity3d.player.UnityPlayer.c(Unknown Source:0)
E Unity   : 	at com.unity3d.player.UnityPlayer$e$2.queueIdle(Unknown Source:72)
E Unity   : 	at android.os.MessageQueue.next(MessageQueue.java:404)
E Unity   : 	at android.os.Looper.loopOnce(Looper.java:186)
E Unity   : 	at android.os.Looper.loop(Looper.java:313)
E Unity   : 	at com.unity3d.player.UnityPlayer$e.run(Unknown Source:32)
E Unity   : Caused by: java.lang.ClassNotFoundException: com.deepwaterooo.sdk.activities.BaseActivity
E Unity   : 	... 10 more
E Unity   :   at UnityEngine.AndroidJNISafe.CheckException () [0x00000] in <filename unknown>:0 
E Unity   :   at UnityEngine.AndroidJNISafe.CallStaticVoidMethod (IntPtr clazz, IntPtr method
E Unity   : NullReferenceException: A null value was found where an object instance was required.
E Unity   :   at GestureRecognizerTS`1[T].CanBegin (.T gesture, IFingerList touches) [0x00000] in <filename unknown>:0 
E Unity   :   at LongPressRecognizer.CanBegin (.LongPressGesture gesture, IFingerList touches) [0x00000] in <filename unknown>:0 
E Unity   :   at GestureRecognizerTS`1[T].UpdateExclusive () [0x00000] in <filename unknown>:0 
E Unity   :   at GestureRecognizerTS`1[T].Update () [0x00000] in <filename unknown>:0 
E Unity   :  
E Unity   : (Filename: currently not available on il2cpp Line: -1)
\end{minted}
\begin{itemize}
\item 在unity中构建,除了上面有限的日志,就再不知道是为什么了
\item 以前17年工作的时候完全不懂怎么把游戏项目倒出到安卓构建,虽然最近一个月左右又稍微练习了一下,可是游戏中构建仍是我的首选.但当出错的时候,源参考项目太复杂,涉及filament安卓平台渲染引擎,和postprocess后期处理,很多细节自己仍然还不够明白.所以从游戏端构建,拿到上面的出错日志无法突破不知道怎么解决的时候,
\item 就不得不硬着头皮导出到安卓构建,试了半下午,现在导出的项目终于可以连通了,是通知配置AndroidManifest.xml文件来实现的:
\begin{minted}[fontsize=\scriptsize,linenos=false]{xml}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.deepwaterooo.dwsdk"
          xmlns:tools="http://schemas.android.com/tools"
          android:theme="@android:style/Theme.NoTitleBar"
          android:versionCode="1"
          android:versionName="1.0"
          android:installLocation="preferExternal">
  <uses-sdk android:minSdkVersion="26" android:targetSdkVersion="26" />

  <supports-screens
      android:smallScreens="false"
      android:normalScreens="false"
      android:largeScreens="false"
      android:xlargeScreens="true"
      android:anyDensity="true"/>

  <!-- <uses-permission android:name="android.permission.ACCESS_NOTIFICATION_POLICY" /> -->
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

  <!-- android:process=":raadidcard" -->
  <!-- android:usesCleartextTraffic="true" -->
  <application
      android:label="@string/app_name"
      android:theme="@style/Theme.AppCompat.DayNight"
      android:allowBackup="true"
      android:isGame="false"
      tools:replace="android:allowBackup"
      android:largeHeap="true"
      android:icon="@mipmap/app_icon">
    <!-- <activity -->
    <!--     android:label="@string/app_name" -->
    <!--     android:screenOrientation="fullSensor" -->
    <!--     android:launchMode="singleTask" -->
    <!--     android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale|layoutDirection|density" -->
    <!--     android:hardwareAccelerated="false" -->
    <!--     android:name="com.deepwaterooo.dwsdk.UnityPlayerActivity" -->
    <!--     android:exported="true"> -->
    <!--   <meta-data android:name="unityplayer.UnityActivity" android:value="true" /> -->
    <!--   <intent-filter> -->
    <!--     <action android:name="android.intent.action.MAIN" /> -->
    <!--     <category android:name="android.intent.category.LAUNCHER" /> -->
    <!--   </intent-filter> -->
    <!-- </activity> -->
    <!-- android:launchMode="singleTask" -->
    <activity android:name="com.deepwaterooo.DWUnityActivity"
              android:label="@string/app_name"
              android:configChanges="mcc|mnc|locale|touchscreen|keyboard|keyboardHidden|navigation|orientation|screenLayout|uiMode|screenSize|smallestScreenSize|fontScale"
              android:exported="true">
      <meta-data android:name="com.deepwaterooo.DWUnityActivity" android:value="true"/>
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
    <!-- <meta-data android:name="android.app.lib_name" android:value="unity" /> -->
    <!-- <activity android:name="com.deepwaterooo.DWSDK"></activity> -->
    <meta-data android:name="unity.build-id" android:value="6ccd546d-e136-4162-ac70-396c442a26ae" />
    <meta-data android:name="unity.splash-mode" android:value="0" />
    <meta-data android:name="unity.splash-enable" android:value="True" />
  </application>
  <uses-feature android:glEsVersion="0x00020000" />
  <uses-feature android:name="android.hardware.gamepad" />
  <uses-feature android:name="android.hardware.vulkan" android:required="false" />
  <!-- <uses-permission android:name="android.permission.INTERNET" /> -->
  <uses-feature android:name="android.hardware.touchscreen" android:required="false" />
  <uses-feature android:name="android.hardware.touchscreen.multitouch" android:required="false" />
  <uses-feature android:name="android.hardware.touchscreen.multitouch.distinct" android:required="false" />
</manifest>
\end{minted}
\item 现在终于可以再往前一小步,在可以找到各种类的情况下,去debug两端(游戏与安卓SDK)交互过程中可能存在的问题了,终于终于又往前一小步![爱表哥,爱生活,一定要嫁给偶亲爱的表哥!!!]
\end{itemize}
% Emacs 27.2 (Org mode 8.2.7c)
\end{document}